# AI 신입생 도우미 - 시스템 구조 설명서

## 개요
본 문서는 AI 신입생 도우미 서비스의 전체 시스템 구조를 비개발자도 이해할 수 있도록 쉽게 설명합니다.

**서비스 목적**: 사용자가 질문을 입력하면, AI가 기존 공지사항과 학사 정보를 기반으로 답변을 제공하는 웹 챗봇 서비스입니다.

---

## 1. 전체 구조 개요

### 1.1 간단한 비유로 이해하기

웹 챗봇 서비스를 **레스토랑**에 비유하면:

```
[고객] → [웨이터] → [주방장] → [냉장고]
  ↓         ↓         ↓         ↓
사용자   Frontend   Backend   Database
         (화면)     (처리)     (저장)
```

- **고객 (사용자)**: 질문을 주문하는 사람
- **웨이터 (Frontend)**: 주문을 받고 음식을 전달하는 사람 (사용자가 보는 화면)
- **주방장 (Backend)**: 주문을 처리하고 요리를 만드는 사람 (중간 처리 서버)
- **AI 요리사 (AI)**: 특별한 요리를 만드는 전문가 (답변 생성)
- **냉장고 (Database)**: 재료를 보관하는 곳 (공지사항, 학사 정보 저장)

### 1.2 4가지 주요 구성 요소

```
┌─────────────┐
│  Frontend   │  ← 사용자가 보는 화면 (웹 페이지)
│  (프론트엔드) │
└──────┬──────┘
       │ 질문 전송
       ↓
┌─────────────┐
│   Backend   │  ← 중간 처리 서버
│  (백엔드)    │
└──────┬──────┘
       │ 데이터 요청
       ↓
┌─────────────┐     ┌─────────────┐
│  Database   │     │     AI      │  ← 답변 생성
│  (데이터베이스) │     │  (인공지능)  │
└─────────────┘     └─────────────┘
```

---

## 2. Frontend (프론트엔드) - 사용자가 보는 화면

### 2.1 역할
**사용자가 직접 보고 상호작용하는 웹 페이지**입니다.

### 2.2 주요 기능

#### 사용자 입장에서 보이는 것:
- ✅ 질문을 입력하는 입력창
- ✅ 대화 내용이 표시되는 채팅 화면
- ✅ 버튼, 메뉴 등 클릭할 수 있는 요소들
- ✅ 예쁘게 꾸며진 디자인

#### 실제로 하는 일:
1. **질문 받기**: 사용자가 입력한 질문을 받아서 Backend로 전달
2. **답변 표시**: Backend에서 받은 답변을 사용자에게 보여주기
3. **화면 구성**: 버튼 클릭, 스크롤 등 사용자 행동 처리

### 2.3 기술 스택 (간단 설명)

- **React**: 웹 페이지를 만드는 도구 (레고 블록처럼 조립)
- **HTML/CSS**: 화면을 꾸미는 언어
- **JavaScript**: 버튼 클릭 등 동작을 처리하는 언어

### 2.4 예시

```
사용자: "수강신청은 언제 하나요?" 입력
  ↓
Frontend: 질문을 Backend로 전송
  ↓
Frontend: Backend에서 받은 답변을 화면에 표시
  ↓
사용자: 답변을 화면에서 확인
```

---

## 3. Backend (백엔드) - 중간 처리 서버

### 3.1 역할
**Frontend와 AI, Database 사이를 연결하는 중간 관리자**입니다.

### 3.2 주요 기능

#### 하는 일:
1. **질문 받기**: Frontend에서 사용자 질문을 받음
2. **질문 전처리**: 질문을 정리하고 분석 (의도 파악, 키워드 추출)
3. **데이터 찾기**: Database에서 관련 공지사항이나 학사 정보를 찾음
   - 키워드 검색: 정확한 단어 매칭
   - 의미 검색: 비슷한 의미의 문서 찾기 (예: "수강신청" = "강의 등록")
4. **데이터 수집**: 찾은 여러 문서를 모아서 정리
5. **AI에게 전달**: 찾은 데이터와 질문을 AI에게 전달
6. **답변 받기**: AI가 만든 답변을 받아서 Frontend로 전달
7. **답변 후처리**: 답변을 검증하고 출처 정보 추가
8. **로깅**: 질문과 답변을 기록 (나중에 분석하기 위해)

### 3.3 비유로 이해하기

**Backend는 우체국 직원**과 같습니다:
- 편지(질문)를 받아서
- 필요한 정보(공지사항)를 찾고
- 전문가(AI)에게 보내서
- 답변을 받아서
- 다시 보낸 사람(Frontend)에게 전달

### 3.4 기술 스택 (간단 설명)

- **Node.js / Python**: 서버를 만드는 도구
- **Express / FastAPI**: 서버 프레임워크 (서버를 쉽게 만드는 도구)
- **API**: Frontend와 Backend가 대화하는 방법

### 3.5 처리 흐름

```
1. Frontend → Backend: "수강신청은 언제 하나요?"
   ↓
2. Backend → Database: "수강신청 관련 공지사항 찾아줘"
   ↓
3. Database → Backend: "수강신청 일정 데이터 전달"
   ↓
4. Backend → AI: "이 질문에 이 데이터로 답변해줘"
   ↓
5. AI → Backend: "답변 완성!"
   ↓
6. Backend → Frontend: "답변 전달"
```

---

## 4. AI (인공지능) - 답변 생성

### 4.1 역할
**질문을 이해하고, 관련 정보를 바탕으로 자연스러운 답변을 만드는 전문가**입니다.

### 4.2 주요 기능

#### 하는 일:
1. **질문 이해**: 사용자가 무엇을 물어보는지 파악
2. **정보 분석**: Backend가 준 공지사항/학사 정보를 읽고 이해
3. **답변 생성**: 이해한 내용을 바탕으로 친절하고 정확한 답변 작성
4. **형식 맞추기**: 기획안에 정해진 형식(요약, 설명, 행동 가이드)으로 답변 구성

### 4.3 비유로 이해하기

**AI는 똑똑한 조교**와 같습니다:
- 학생의 질문을 잘 이해하고
- 학교 공지사항을 읽어서
- 쉬운 말로 설명해주고
- 다음에 뭘 해야 하는지 알려줌

### 4.4 사용 가능한 AI 모델

- **GPT-4 / Claude**: OpenAI나 Anthropic에서 만든 대형 언어 모델
- **LLM (Large Language Model)**: 많은 텍스트를 학습한 AI 모델

### 4.5 RAG 패턴 (Retrieval-Augmented Generation) - 검색 기반 답변 생성

**RAG는 AI가 정확한 답변을 하기 위한 최신 방법**입니다.

#### 왜 RAG가 필요한가요?
- AI가 혼자서 답변하면 **잘못된 정보를 만들 수 있음** (환각 현상)
- RAG는 **실제 문서를 먼저 찾아서** 그 내용을 바탕으로 답변함
- 더 정확하고 신뢰할 수 있는 답변 제공

#### RAG 작동 방식 (비유로 이해하기):
```
1. 질문: "수강신청은 언제 하나요?"
   ↓
2. 도서관에서 관련 책 찾기 (Database에서 관련 공지사항 검색)
   ↓
3. 찾은 책의 내용 읽기 (관련 문서 내용 가져오기)
   ↓
4. 책 내용을 바탕으로 답변 작성 (AI가 문서 기반으로 답변 생성)
   ↓
5. 어떤 책에서 가져왔는지 표시 (출처 표기)
```

#### RAG의 장점:
- ✅ **정확성**: 실제 문서 기반으로 답변하므로 더 정확함
- ✅ **신뢰성**: 출처를 명시할 수 있어 신뢰도 향상
- ✅ **최신 정보**: Database를 업데이트하면 최신 정보로 답변 가능
- ✅ **환각 방지**: 모르는 내용을 추측하지 않음

### 4.6 AI가 답변을 만드는 과정 (RAG 방식)

```
입력:
- 질문: "수강신청은 언제 하나요?"
- 관련 데이터: "2025학년도 학사일정: 1학기 수강신청 3월 1일~5일"

처리:
1. 질문 분석: "수강신청 일정을 묻고 있구나"
2. 데이터 검색: Database에서 "수강신청" 관련 문서 찾기
3. 데이터 분석: "1학기는 3월 1일~5일이구나"
4. 컨텍스트 조립: 질문 + 찾은 문서 내용 + 시스템 지시사항 결합
5. 답변 생성: "수강신청 일정 안내..."

출력:
"수강신청 일정 안내
• 1학기: 3월 1일~5일
• 2학기: 8월 초
...
[출처: 2025학년도 학사일정]"
```

### 4.7 중요한 제약 사항

- ✅ **제공된 데이터만 사용**: Database에 있는 공지사항/학사 정보만 기반으로 답변
- ❌ **추측 금지**: 모르는 내용은 "확인되지 않았어요"라고 답변
- ✅ **출처 표기**: 답변에 사용한 정보의 출처를 명시
- ✅ **폴백 메커니즘**: AI가 답변을 못 만들면 안전한 기본 메시지 표시

---

## 5. Database (데이터베이스) - 데이터 저장소

### 5.1 역할
**공지사항, 학사 일정, 지원 프로그램 등 모든 정보를 저장하는 창고**입니다.

### 5.2 주요 기능

#### 저장하는 정보:
- 📅 **학사 일정**: 수강신청 일정, 등록금 납부 일정, 시험 일정 등
- 📢 **공지사항**: 학교에서 발표한 각종 공지
- 💡 **지원 프로그램**: 장학금, 비교과 프로그램, 멘토링 정보
- 📚 **학사 용어**: 학사 제도 설명, 용어 사전

#### 하는 일:
1. **데이터 저장**: 새로운 공지사항이나 학사 정보를 저장
2. **데이터 검색**: Backend가 요청한 정보를 찾아서 제공
3. **데이터 관리**: 오래된 정보 업데이트, 삭제 등

### 5.3 비유로 이해하기

**Database는 도서관**과 같습니다:
- 책(공지사항)을 정리해서 보관하고
- 필요한 책을 찾아서 빌려주고
- 새로운 책이 들어오면 추가하고
- 오래된 책은 업데이트하거나 제거

### 5.4 기술 스택 (간단 설명)

#### 관계형 데이터베이스 (Relational Database)
- **PostgreSQL / MySQL**: 데이터를 표 형태로 저장하는 프로그램
- **SQL**: 데이터를 찾고 저장하는 언어
- **용도**: 구조화된 데이터 (학사 일정, 공지사항 메타데이터 등)

#### 벡터 데이터베이스 (Vector Database) - 선택 사항
- **Pinecone / Weaviate / Qdrant**: 문서의 의미를 숫자로 변환해서 저장
- **용도**: 의미 기반 검색 (예: "수강신청"과 "강의 등록"을 같은 의미로 인식)
- **작동 방식**: 
  - 문서를 숫자 벡터로 변환 (임베딩)
  - 질문도 벡터로 변환
  - 비슷한 벡터를 가진 문서를 찾음

#### 하이브리드 검색 (Hybrid Search)
- **키워드 검색 + 의미 검색**을 함께 사용
- 키워드로 빠르게 찾고, 의미 검색으로 더 정확한 결과 찾기
- 예: "수강신청" 키워드 검색 + "강의 등록" 의미 검색

### 5.5 데이터 구조 예시

```
학사 일정 테이블:
- 일정명: "1학기 수강신청"
- 시작일: "2025-03-01"
- 종료일: "2025-03-05"
- 학기: "1학기"
- 설명: "..."

공지사항 테이블:
- 제목: "2025학년도 1학기 수강신청 안내"
- 내용: "..."
- 작성일: "2025-01-15"
- 중요도: "높음"
```

---

## 6. 전체 시스템 흐름도

### 6.1 사용자가 질문하는 전체 과정

```
[1단계] 사용자가 질문 입력
┌─────────────┐
│   사용자     │ "수강신청은 언제 하나요?"
└──────┬──────┘
       │
       ↓
[2단계] Frontend가 질문을 Backend로 전송
┌─────────────┐      HTTP 요청      ┌─────────────┐
│  Frontend   │ ──────────────────→ │   Backend   │
│  (화면)      │                     │  (서버)      │
└─────────────┘                     └──────┬──────┘
                                           │
                                           ↓
[3단계] Backend가 Database에서 관련 정보 검색
┌─────────────┐      데이터 요청     ┌─────────────┐
│   Backend   │ ──────────────────→ │  Database   │
│  (서버)      │                     │  (저장소)    │
└─────────────┘ ←────────────────── └─────────────┘
       │              관련 공지사항 전달
       │
       ↓
[4단계] Backend가 AI에게 질문과 데이터 전달
┌─────────────┐      질문 + 데이터    ┌─────────────┐
│   Backend   │ ──────────────────→ │     AI      │
│  (서버)      │                     │ (인공지능)   │
└─────────────┘ ←────────────────── └─────────────┘
       │              답변 생성 완료
       │
       ↓
[5단계] Backend가 답변을 Frontend로 전달
┌─────────────┐      HTTP 응답      ┌─────────────┐
│   Backend   │ ──────────────────→ │  Frontend   │
│  (서버)      │                     │  (화면)      │
└─────────────┘                     └──────┬──────┘
                                           │
                                           ↓
[6단계] Frontend가 사용자에게 답변 표시
┌─────────────┐
│   사용자     │ "수강신청 일정 안내..."
└─────────────┘
```

### 6.2 시간 순서로 보는 흐름

```
0초: 사용자가 질문 입력
  ↓
0.1초: Frontend가 Backend로 전송
  ↓
0.2초: Backend가 Database에서 정보 검색
  ↓
0.3초: Database가 관련 정보 반환
  ↓
0.4초: Backend가 AI에게 질문과 데이터 전달
  ↓
1.5초: AI가 답변 생성 완료
  ↓
1.6초: Backend가 Frontend로 답변 전달
  ↓
1.7초: 사용자가 화면에서 답변 확인
```

---

## 7. 각 구성 요소 간 통신 방법

### 7.1 Frontend ↔ Backend 통신

**방법**: HTTP/HTTPS (웹에서 정보를 주고받는 표준 방법)

**예시**:
```
Frontend → Backend: 
POST /api/chat
{
  "question": "수강신청은 언제 하나요?"
}

Backend → Frontend:
{
  "answer": "수강신청 일정 안내...",
  "source": "2025학년도 학사일정"
}
```

### 7.2 Backend ↔ Database 통신

**방법**: SQL 쿼리 (데이터베이스 언어)

**예시**:
```
Backend → Database:
SELECT * FROM notices 
WHERE title LIKE '%수강신청%'

Database → Backend:
[
  {
    "title": "2025학년도 1학기 수강신청 안내",
    "content": "...",
    "date": "2025-03-01"
  }
]
```

### 7.3 Backend ↔ AI 통신

**방법**: API 호출 (AI 서비스 제공 업체의 API 사용)

**예시**:
```
Backend → AI:
{
  "prompt": "다음 정보를 바탕으로 질문에 답변해주세요.
            질문: 수강신청은 언제 하나요?
            정보: 1학기 수강신청: 3월 1일~5일"
}

AI → Backend:
{
  "answer": "수강신청 일정 안내..."
}
```

---

## 8. 데이터 흐름 상세 설명

### 8.1 질문 처리 과정

#### Step 1: 질문 입력
- 사용자가 웹 페이지에서 질문 입력
- Frontend가 입력 내용을 받음

#### Step 2: 질문 전송
- Frontend가 HTTP 요청으로 Backend에 질문 전송
- 질문 내용, 사용자 정보 등 포함

#### Step 3: 데이터 검색
- Backend가 Database에 질문과 관련된 정보 검색 요청
- 예: "수강신청" 키워드로 공지사항 검색

#### Step 4: 데이터 수집
- Database가 관련 정보를 찾아서 Backend에 전달
- 여러 개의 공지사항이나 학사 정보가 포함될 수 있음

#### Step 5: AI 처리
- Backend가 질문과 수집한 데이터를 AI에게 전달
- AI가 데이터를 분석하고 답변 생성

#### Step 6: 답변 반환
- AI가 생성한 답변을 Backend에 전달
- Backend가 답변을 정리하고 출처 정보 추가

#### Step 7: 화면 표시
- Backend가 Frontend에 답변 전달
- Frontend가 사용자 화면에 답변 표시

### 8.2 데이터 저장 과정

#### 새로운 공지사항 추가 시:

```
1. 관리자가 공지사항 입력
   ↓
2. Backend가 공지사항을 받음
   ↓
3. Backend가 Database에 저장 요청
   ↓
4. Database에 공지사항 저장 완료
   ↓
5. 이후 질문 시 이 공지사항이 검색됨
```

---

## 9. 보안 및 안정성

### 9.1 보안 조치

#### 사용자 데이터 보호:
- ✅ 사용자 질문은 로그에만 저장 (개인정보 제외)
- ✅ HTTPS 사용으로 통신 암호화 (데이터 전송 중 보호)
- ✅ 서버 접근 권한 관리 (인증 및 권한 체계)
- ✅ API 키 보안 관리 (환경 변수로 관리, 코드에 노출 금지)

#### 데이터 보호:
- ✅ Database 접근 권한 제한 (최소 권한 원칙)
- ✅ 정기적인 데이터 백업 (일일 또는 주간 백업)
- ✅ 공지사항 무단 수정 방지 (관리자만 수정 가능)
- ✅ 데이터 암호화 (저장 시 암호화, 전송 시 암호화)

#### 대학 챗봇 특화 보안:
- ✅ **개인정보 보호**: 학생 정보, 성적 등 민감 정보 처리 시 주의
- ✅ **접근 제어**: 역할 기반 접근 (학생, 교직원, 관리자)
- ✅ **감사 로그**: 누가 언제 무엇을 했는지 기록

### 9.2 안정성 확보

#### 서버 다운 방지:
- ✅ 여러 서버로 부하 분산 (필요 시)
- ✅ 오류 발생 시 자동 복구 (Circuit Breaker 패턴)
- ✅ 정기적인 서버 상태 모니터링
- ✅ 폴백 메커니즘: AI가 실패하면 기본 응답 제공

#### 데이터 손실 방지:
- ✅ 정기적인 데이터 백업 (일일 자동 백업)
- ✅ 여러 곳에 데이터 복사본 저장 (재해 복구)
- ✅ 데이터 버전 관리 (변경 이력 추적)

#### 성능 최적화:
- ✅ **캐싱**: 자주 묻는 질문의 답변을 임시 저장
- ✅ **비동기 처리**: 긴 작업은 백그라운드에서 처리
- ✅ **Rate Limiting**: API 호출 제한으로 서버 보호

---

## 10. 모니터링 및 로깅

### 10.1 모니터링이란?
**시스템이 잘 작동하는지 지속적으로 확인하는 것**입니다.

### 10.2 모니터링 항목

#### 성능 모니터링:
- ⏱️ **응답 시간**: 질문 입력부터 답변 받기까지 걸리는 시간
- 📊 **처리량**: 하루에 몇 개의 질문을 처리하는지
- 🔄 **에러율**: 실패한 요청의 비율

#### 사용자 모니터링:
- 👥 **활성 사용자 수**: 하루에 몇 명이 사용하는지
- 💬 **인기 질문**: 가장 많이 묻는 질문은 무엇인지
- 📈 **사용자 만족도**: 답변이 도움이 되었는지 피드백

#### 시스템 모니터링:
- 🖥️ **서버 상태**: 서버가 정상 작동하는지
- 💾 **데이터베이스 상태**: 데이터베이스가 정상인지
- 🤖 **AI API 상태**: AI 서비스가 정상인지

### 10.3 로깅 (기록)

#### 기록하는 내용:
- 사용자 질문과 답변 (개인정보 제외)
- 에러 발생 시 에러 내용
- 시스템 성능 데이터
- 사용자 피드백

#### 로깅의 목적:
- 문제 발생 시 원인 파악
- 서비스 개선을 위한 데이터 수집
- 사용 패턴 분석

### 10.4 대학 챗봇 특화 모니터링

#### 학기별 트렌드:
- 📅 **학기 시작 시**: 수강신청 관련 질문 증가 예상
- 📅 **시험 기간**: 시험 일정, 성적 관련 질문 증가
- 📅 **등록금 납부 기간**: 등록금 관련 질문 증가

#### 질문 분석:
- 어떤 질문이 가장 많은지
- 어떤 질문에 답변을 못했는지
- 어떤 답변이 부정확했는지

---

## 11. 확장 가능성

### 10.1 향후 추가 가능한 기능

#### 현재 구조에서 쉽게 추가 가능:
- 📧 **이메일 알림**: 중요한 공지사항 알림
- 📱 **모바일 앱**: 네이티브 앱 버전
- 🔔 **푸시 알림**: 실시간 공지사항 알림
- 📊 **통계 대시보드**: 질문 통계, 인기 질문 등

#### 구조 변경이 필요한 기능:
- 👥 **사용자 계정**: 개인화된 정보 저장
- 💬 **대화 이력**: 이전 대화 내용 저장
- 🌐 **다국어 지원**: 영어, 중국어 등

---

## 12. 대학 챗봇 특화 고려사항

### 12.1 하이브리드 접근 방식

대학 챗봇은 **여러 방법을 조합**해서 사용하는 것이 좋습니다:

#### 규칙 기반 (Rule-Based):
- **용도**: 예측 가능한 질문 (예: "수강신청은 언제 하나요?")
- **장점**: 빠르고 정확함
- **예시**: 미리 정해진 답변 템플릿 사용

#### 검색 기반 (Retrieval-Based):
- **용도**: 문서에서 정보 찾기 (예: 공지사항, 학사 규정)
- **장점**: 실제 문서 기반으로 답변
- **예시**: Database에서 관련 문서 검색 후 표시

#### 생성 기반 (Generative):
- **용도**: 복잡한 질문, 대화형 상담
- **장점**: 자연스럽고 유연한 답변
- **예시**: AI가 문서를 읽고 요약하여 답변 생성

### 12.2 학기별 대응 전략

#### 학기 시작 전:
- 수강신청, 등록금 납부 관련 질문 증가 예상
- 관련 정보를 우선적으로 제공하도록 설정

#### 학기 중:
- 일정 확인, 공지사항 확인 질문 증가
- 실시간 정보 업데이트 중요

#### 시험 기간:
- 시험 일정, 성적 관련 질문 증가
- 스트레스 완화를 위한 친절한 톤 유지

### 12.3 접근성 고려사항

#### 다양한 사용자 지원:
- 🎓 **신입생**: 기본 용어 설명 필요
- 🎓 **재학생**: 더 구체적인 정보 필요
- 👨‍🏫 **교직원**: 다른 관점의 정보 필요

#### 다중 채널 지원 (향후):
- 웹사이트
- 모바일 앱
- LMS 통합 (예: Canvas, Blackboard)
- 메신저 앱 (예: 카카오톡)

### 12.4 에스컬레이션 (Escalation) - 인간 상담원 연결

#### 언제 인간 상담원이 필요한가?
- 복잡한 개인적인 문제
- AI가 답변하지 못한 질문
- 사용자가 직접 상담을 요청한 경우

#### 에스컬레이션 프로세스:
```
1. 사용자가 "상담원 연결" 요청
   ↓
2. Backend가 상담 시스템에 연결 요청
   ↓
3. 대화 이력을 상담원에게 전달
   ↓
4. 상담원이 직접 응답
```

---

## 13. 기술 스택 요약

### 13.1 Frontend
- **React**: 웹 페이지 구성
- **Tailwind CSS**: 스타일링
- **JavaScript**: 동작 처리

### 13.2 Backend
- **Node.js / Python**: 서버 구축
- **Express / FastAPI**: 서버 프레임워크
- **REST API**: 통신 방식
- **LangChain / LlamaIndex**: RAG 파이프라인 관리 (선택)

### 13.3 AI
- **GPT-4 / Claude**: AI 모델
- **OpenAI API / Anthropic API**: AI 서비스 연동
- **임베딩 모델**: 문서를 벡터로 변환 (예: OpenAI Embeddings)

### 13.4 Database
- **PostgreSQL / MySQL**: 관계형 데이터베이스 (구조화된 데이터)
- **Vector Database**: 벡터 데이터베이스 (의미 검색용, 선택)
  - Pinecone, Weaviate, Qdrant, Supabase + pgvector 등
- **MongoDB**: 문서형 데이터베이스 (선택)

---

## 14. 비용 구조 (참고)

### 14.1 주요 비용 항목

#### 개발 비용:
- Frontend 개발
- Backend 개발
- Database 설계 및 구축
- AI 모델 통합 및 테스트

#### 운영 비용:
- 서버 호스팅 비용 (월간)
- AI API 사용 비용 (질문당 과금 또는 월간 구독)
  - OpenAI GPT-4: 토큰당 과금
  - Claude: 토큰당 과금
- Database 저장 공간 비용
- Vector Database 비용 (사용 시)
- 도메인 및 SSL 인증서 비용
- 모니터링 및 로깅 도구 비용

### 14.2 비용 최적화 팁

- ✅ **AI API 호출 최소화**: 캐싱 활용, 자주 묻는 질문은 미리 저장
- ✅ **서버 리소스 효율적 사용**: 필요할 때만 확장 (Auto-scaling)
- ✅ **불필요한 데이터 저장 방지**: 오래된 로그 정기 삭제
- ✅ **하이브리드 접근**: 간단한 질문은 규칙 기반으로 처리
- ✅ **벡터 DB 선택**: 무료/오픈소스 옵션 고려 (예: Supabase + pgvector)

---

## 15. 개발 단계별 우선순위

### 15.1 Phase 1: 기본 구조 구축
1. Frontend 기본 화면 구성
2. Backend 기본 서버 구축
3. Database 기본 구조 설계 (관계형 DB)
4. 기본 API 엔드포인트 구축

### 15.2 Phase 2: 핵심 기능 구현
1. 질문 입력 및 전송 기능
2. Database에서 데이터 검색 기능 (키워드 검색)
3. AI API 연동 및 답변 생성
4. 기본 RAG 파이프라인 구현

### 15.3 Phase 3: 데이터 구축
1. 공지사항 데이터 입력
2. 학사 일정 데이터 입력
3. 지원 프로그램 데이터 입력
4. 데이터 검증 및 정제

### 15.4 Phase 4: 고급 기능 (선택)
1. Vector Database 도입 (의미 검색)
2. 하이브리드 검색 구현
3. 캐싱 시스템 구축
4. 모니터링 및 로깅 시스템

### 15.5 Phase 5: 테스트 및 최적화
1. 다양한 질문으로 테스트
2. 답변 품질 검증
3. 성능 최적화
4. 사용자 피드백 수집 및 개선

---

## 16. FAQ (자주 묻는 질문)

### Q1: Frontend와 Backend의 차이가 뭔가요?
**A**: Frontend는 사용자가 보는 화면이고, Backend는 그 뒤에서 일하는 서버입니다. 레스토랑에서 웨이터(Frontend)가 고객을 맞이하고, 주방(Backend)에서 요리를 만드는 것과 비슷합니다.

### Q2: AI 없이도 서비스가 가능한가요?
**A**: 가능하지만, 질문에 대한 답변을 자동으로 생성하는 기능이 없어집니다. AI 대신 미리 작성된 답변 템플릿을 사용할 수 있지만, 유연성이 떨어집니다. 규칙 기반 시스템으로 시작하고 점진적으로 AI를 도입하는 것도 방법입니다.

### Q3: Database에 데이터를 어떻게 넣나요?
**A**: 관리자 페이지를 통해 수동으로 입력하거나, 학교 공식 사이트에서 자동으로 가져오는 스크립트를 만들 수 있습니다. 정기적으로 업데이트하는 파이프라인을 구축하는 것이 좋습니다.

### Q4: 서버가 다운되면 어떻게 되나요?
**A**: 사용자가 서비스를 사용할 수 없게 됩니다. 이를 방지하기 위해 여러 서버를 운영하거나, 클라우드 서비스를 사용합니다. 또한 폴백 메커니즘을 구현하여 일부 기능이 실패해도 기본 서비스는 제공할 수 있습니다.

### Q5: AI가 잘못된 답변을 하면 어떻게 하나요?
**A**: RAG 패턴을 사용하여 실제 문서만 기반으로 답변하도록 하고, Database에 정확한 정보만 저장합니다. AI에게 "모르는 내용은 추측하지 말라"고 지시하고, 사용자 피드백을 받아서 답변을 개선합니다. 또한 답변 검증 단계를 추가할 수 있습니다.

### Q6: Vector Database가 꼭 필요한가요?
**A**: 필수는 아닙니다. 초기에는 키워드 검색만으로도 충분할 수 있습니다. 하지만 의미 기반 검색이 필요하거나, 더 정확한 검색 결과가 필요할 때 도입을 고려할 수 있습니다.

### Q7: RAG가 무엇인가요?
**A**: RAG (Retrieval-Augmented Generation)는 검색 기반 답변 생성 방법입니다. AI가 답변을 만들기 전에 실제 문서를 먼저 찾아서 그 내용을 바탕으로 답변합니다. 이렇게 하면 더 정확하고 신뢰할 수 있는 답변을 제공할 수 있습니다.

### Q8: 하이브리드 접근 방식이란 무엇인가요?
**A**: 여러 방법을 조합해서 사용하는 것입니다. 예를 들어, 간단한 질문은 규칙 기반으로 빠르게 답변하고, 복잡한 질문은 AI가 생성하도록 하는 방식입니다. 이렇게 하면 정확성과 속도를 모두 확보할 수 있습니다.

---

## 17. 용어 사전

### API (Application Programming Interface)
- 프로그램들이 서로 대화하는 방법
- 예: Frontend가 Backend에게 "질문 좀 처리해줘"라고 요청하는 방법

### HTTP/HTTPS
- 웹에서 정보를 주고받는 규칙
- HTTP는 일반 통신, HTTPS는 암호화된 안전한 통신

### 서버 (Server)
- 24시간 돌아가면서 요청을 처리하는 컴퓨터
- 사용자가 자는 동안에도 서비스를 제공

### 데이터베이스 (Database)
- 정보를 체계적으로 저장하는 저장소
- 엑셀 시트처럼 표 형태로 데이터를 관리

### 프레임워크 (Framework)
- 프로그램을 쉽게 만들 수 있게 도와주는 도구
- 레고 블록처럼 미리 만들어진 부품을 조립하는 것

### 쿼리 (Query)
- 데이터베이스에서 정보를 찾는 명령어
- 예: "수강신청이라는 단어가 들어간 공지사항 찾아줘"

### RAG (Retrieval-Augmented Generation)
- 검색 기반 답변 생성 방법
- AI가 답변하기 전에 실제 문서를 먼저 찾아서 그 내용을 바탕으로 답변 생성
- 더 정확하고 신뢰할 수 있는 답변 제공

### 임베딩 (Embedding)
- 문서나 단어를 숫자 벡터로 변환하는 것
- 비슷한 의미의 문서는 비슷한 벡터를 가짐
- 의미 기반 검색에 사용

### 벡터 데이터베이스 (Vector Database)
- 임베딩(벡터)을 저장하고 검색하는 데이터베이스
- 의미 기반 검색에 사용
- 예: Pinecone, Weaviate, Qdrant

### 하이브리드 검색 (Hybrid Search)
- 키워드 검색과 의미 검색을 함께 사용하는 방법
- 더 정확한 검색 결과 제공

### 폴백 (Fallback)
- 주 방법이 실패했을 때 사용하는 대체 방법
- 예: AI가 답변을 못 만들면 기본 메시지 표시

### 캐싱 (Caching)
- 자주 사용하는 데이터를 임시로 저장해두는 것
- 빠른 응답을 위해 사용
- 예: 자주 묻는 질문의 답변을 미리 저장

### 에스컬레이션 (Escalation)
- AI가 처리하지 못한 경우 인간 상담원에게 연결하는 것
- 복잡한 문제나 개인적인 상담이 필요할 때 사용

---

## 18. 다이어그램 요약

### 18.1 전체 구조 다이어그램

```
                    ┌─────────────┐
                    │   사용자     │
                    │  (브라우저)   │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  Frontend   │
                    │  (React)    │
                    └──────┬──────┘
                           │ HTTP
                    ┌──────▼──────┐
                    │   Backend   │
                    │ (Node.js)   │
                    └──┬──────┬───┘
                       │      │
                  SQL  │      │ API
                       │      │
            ┌──────────┘      └──────────┐
            │                             │
    ┌───────▼───────┐           ┌────────▼────────┐
    │  Database     │           │       AI        │
    │ (PostgreSQL)  │           │   (GPT-4 API)   │
    └───────────────┘           └─────────────────┘
```

### 18.2 데이터 흐름 다이어그램 (기본)

```
질문 입력
    ↓
Frontend (화면 표시)
    ↓ HTTP 요청
Backend (질문 받기)
    ↓ SQL 쿼리
Database (데이터 검색)
    ↓ 데이터 반환
Backend (데이터 수집)
    ↓ API 호출
AI (답변 생성)
    ↓ 답변 반환
Backend (답변 정리)
    ↓ HTTP 응답
Frontend (답변 표시)
    ↓
사용자 확인
```

### 18.3 RAG 흐름 다이어그램 (고급)

```
사용자 질문 입력
    ↓
Backend: 질문 전처리 및 분석
    ↓
Backend: 질문을 벡터로 변환 (임베딩)
    ↓
Vector Database: 비슷한 의미의 문서 검색
    ↓
Database: 관련 문서 내용 가져오기
    ↓
Backend: 질문 + 문서 내용 + 시스템 지시사항 결합
    ↓
AI: 컨텍스트를 바탕으로 답변 생성
    ↓
Backend: 답변 검증 및 출처 추가
    ↓
Frontend: 답변 표시 (출처 포함)
```

### 18.4 하이브리드 검색 다이어그램

```
사용자 질문: "수강신청은 언제 하나요?"
    ↓
┌─────────────────────────────────────┐
│  키워드 검색 (Keyword Search)       │
│  "수강신청" 단어가 포함된 문서 찾기 │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  의미 검색 (Semantic Search)         │
│  "강의 등록", "과목 신청" 등         │
│  비슷한 의미의 문서 찾기             │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  결과 통합 및 순위 결정              │
│  두 검색 결과를 합쳐서               │
│  가장 관련성 높은 문서 선택          │
└─────────────────────────────────────┘
```

---

## 19. 결론

### 17.1 핵심 요약

이 서비스는 **4개의 주요 구성 요소**로 이루어져 있습니다:

1. **Frontend**: 사용자가 보는 화면
2. **Backend**: 중간 처리 서버
3. **AI**: 답변 생성
4. **Database**: 데이터 저장

각 구성 요소는 서로 협력하여 사용자의 질문에 답변을 제공합니다.

### 17.2 핵심 아키텍처 패턴

- ✅ **RAG (Retrieval-Augmented Generation)**: 검색 기반 답변 생성으로 정확성 향상
- ✅ **하이브리드 접근**: 규칙 기반 + 검색 기반 + 생성 기반 조합
- ✅ **하이브리드 검색**: 키워드 검색 + 의미 검색으로 더 정확한 결과
- ✅ **폴백 메커니즘**: 실패 시 안전한 대체 방법 제공

### 17.3 개발 시 주의사항

- ✅ 각 구성 요소의 역할을 명확히 구분
- ✅ 구성 요소 간 통신 방법을 표준화
- ✅ 데이터의 정확성 유지 (RAG 패턴 활용)
- ✅ 사용자 경험 최우선
- ✅ 보안 및 프라이버시 고려 (대학 데이터 특성)
- ✅ 모니터링 및 로깅으로 지속적 개선

### 17.4 향후 발전 방향

- **초기 단계**: 규칙 기반 + 기본 검색
- **성장 단계**: RAG 패턴 도입, Vector Database 추가
- **성숙 단계**: 하이브리드 검색, 다중 채널 지원, 고급 모니터링

---

**작성일**: 2026년 1월 21일  
**최종 수정일**: 2026년 1월 21일  
**버전**: 1.1 (웹 리서치 기반 보완)  
**대상**: 비개발자 이해를 위한 구조 설명서

---

**본 문서는 AI 신입생 도우미 서비스의 전체 시스템 구조를 이해하기 위한 가이드입니다.  
기술적 세부사항보다는 전체적인 흐름과 각 구성 요소의 역할을 이해하는 데 중점을 둡니다.  
웹 리서치를 통해 최신 베스트 프랙티스(RAG, 하이브리드 검색 등)를 반영하여 보완되었습니다.**
